// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: yyl_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum yyl_report_type: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case yylReportAuto // = 0
  case yylReportManual // = 1

  init() {
    self = .yylReportAuto
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .yylReportAuto
    case 1: self = .yylReportManual
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .yylReportAuto: return 0
    case .yylReportManual: return 1
    }
  }

}

struct yyl_wuqi_report: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wq: Data {
    get {return _wq ?? Data()}
    set {_wq = newValue}
  }
  /// Returns true if `wq` has been explicitly set.
  var hasWq: Bool {return self._wq != nil}
  /// Clears the value of `wq`. Subsequent reads from it will return its default value.
  mutating func clearWq() {self._wq = nil}

  var score: Data {
    get {return _score ?? Data()}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  mutating func clearScore() {self._score = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _wq: Data? = nil
  fileprivate var _score: Data? = nil
}

struct yyl_body_report: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tzName: Data {
    get {return _tzName ?? Data()}
    set {_tzName = newValue}
  }
  /// Returns true if `tzName` has been explicitly set.
  var hasTzName: Bool {return self._tzName != nil}
  /// Clears the value of `tzName`. Subsequent reads from it will return its default value.
  mutating func clearTzName() {self._tzName = nil}

  var tzScore: Data {
    get {return _tzScore ?? Data()}
    set {_tzScore = newValue}
  }
  /// Returns true if `tzScore` has been explicitly set.
  var hasTzScore: Bool {return self._tzScore != nil}
  /// Clears the value of `tzScore`. Subsequent reads from it will return its default value.
  mutating func clearTzScore() {self._tzScore = nil}

  var preTzName: Data {
    get {return _preTzName ?? Data()}
    set {_preTzName = newValue}
  }
  /// Returns true if `preTzName` has been explicitly set.
  var hasPreTzName: Bool {return self._preTzName != nil}
  /// Clears the value of `preTzName`. Subsequent reads from it will return its default value.
  mutating func clearPreTzName() {self._preTzName = nil}

  var preTzScore: Data {
    get {return _preTzScore ?? Data()}
    set {_preTzScore = newValue}
  }
  /// Returns true if `preTzScore` has been explicitly set.
  var hasPreTzScore: Bool {return self._preTzScore != nil}
  /// Clears the value of `preTzScore`. Subsequent reads from it will return its default value.
  mutating func clearPreTzScore() {self._preTzScore = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tzName: Data? = nil
  fileprivate var _tzScore: Data? = nil
  fileprivate var _preTzName: Data? = nil
  fileprivate var _preTzScore: Data? = nil
}

struct yyl_notify: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hasReport_p: Bool {
    get {return _hasReport_p ?? false}
    set {_hasReport_p = newValue}
  }
  /// Returns true if `hasReport_p` has been explicitly set.
  var hasHasReport_p: Bool {return self._hasReport_p != nil}
  /// Clears the value of `hasReport_p`. Subsequent reads from it will return its default value.
  mutating func clearHasReport_p() {self._hasReport_p = nil}

  var reportType: yyl_report_type {
    get {return _reportType ?? .yylReportAuto}
    set {_reportType = newValue}
  }
  /// Returns true if `reportType` has been explicitly set.
  var hasReportType: Bool {return self._reportType != nil}
  /// Clears the value of `reportType`. Subsequent reads from it will return its default value.
  mutating func clearReportType() {self._reportType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hasReport_p: Bool? = nil
  fileprivate var _reportType: yyl_report_type? = nil
}

struct yyl_Command: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var modeling: Bool {
    get {return _modeling ?? false}
    set {_modeling = newValue}
  }
  /// Returns true if `modeling` has been explicitly set.
  var hasModeling: Bool {return self._modeling != nil}
  /// Clears the value of `modeling`. Subsequent reads from it will return its default value.
  mutating func clearModeling() {self._modeling = nil}

  var wuqiReport: yyl_wuqi_report {
    get {return _wuqiReport ?? yyl_wuqi_report()}
    set {_wuqiReport = newValue}
  }
  /// Returns true if `wuqiReport` has been explicitly set.
  var hasWuqiReport: Bool {return self._wuqiReport != nil}
  /// Clears the value of `wuqiReport`. Subsequent reads from it will return its default value.
  mutating func clearWuqiReport() {self._wuqiReport = nil}

  var bodyReport: yyl_body_report {
    get {return _bodyReport ?? yyl_body_report()}
    set {_bodyReport = newValue}
  }
  /// Returns true if `bodyReport` has been explicitly set.
  var hasBodyReport: Bool {return self._bodyReport != nil}
  /// Clears the value of `bodyReport`. Subsequent reads from it will return its default value.
  mutating func clearBodyReport() {self._bodyReport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _modeling: Bool? = nil
  fileprivate var _wuqiReport: yyl_wuqi_report? = nil
  fileprivate var _bodyReport: yyl_body_report? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension yyl_report_type: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YYL_REPORT_AUTO"),
    1: .same(proto: "YYL_REPORT_MANUAL"),
  ]
}

extension yyl_wuqi_report: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "yyl_wuqi_report"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wq"),
    2: .same(proto: "score"),
  ]

  public var isInitialized: Bool {
    if self._wq == nil {return false}
    if self._score == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._wq) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wq {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._score {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: yyl_wuqi_report, rhs: yyl_wuqi_report) -> Bool {
    if lhs._wq != rhs._wq {return false}
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension yyl_body_report: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "yyl_body_report"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tz_name"),
    2: .standard(proto: "tz_score"),
    3: .standard(proto: "pre_tz_name"),
    4: .standard(proto: "pre_tz_score"),
  ]

  public var isInitialized: Bool {
    if self._tzName == nil {return false}
    if self._tzScore == nil {return false}
    if self._preTzName == nil {return false}
    if self._preTzScore == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._tzName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._tzScore) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._preTzName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._preTzScore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tzName {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tzScore {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._preTzName {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._preTzScore {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: yyl_body_report, rhs: yyl_body_report) -> Bool {
    if lhs._tzName != rhs._tzName {return false}
    if lhs._tzScore != rhs._tzScore {return false}
    if lhs._preTzName != rhs._preTzName {return false}
    if lhs._preTzScore != rhs._preTzScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension yyl_notify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "yyl_notify"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_report"),
    2: .standard(proto: "report_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._hasReport_p) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._reportType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hasReport_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reportType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: yyl_notify, rhs: yyl_notify) -> Bool {
    if lhs._hasReport_p != rhs._hasReport_p {return false}
    if lhs._reportType != rhs._reportType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension yyl_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "yyl_Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modeling"),
    4: .standard(proto: "wuqi_report"),
    5: .standard(proto: "body_report"),
  ]

  public var isInitialized: Bool {
    if let v = self._wuqiReport, !v.isInitialized {return false}
    if let v = self._bodyReport, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._modeling) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._wuqiReport) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bodyReport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modeling {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wuqiReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bodyReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: yyl_Command, rhs: yyl_Command) -> Bool {
    if lhs._modeling != rhs._modeling {return false}
    if lhs._wuqiReport != rhs._wuqiReport {return false}
    if lhs._bodyReport != rhs._bodyReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
